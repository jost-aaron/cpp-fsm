import os
from parser import parse,reset
import sys

debug = False 
#debug = True

# TODO ADD like converting state to string and stuff for debugging

GENERATED_CODE_BANNER = """\
//**************************************************************
//*** NOTICE: This file was generated by CPP-FSM DO NOT EDIT ***
//**************************************************************

"""

HEADER_GUARD_START = """\
#pragma once

"""
HEADER_GUARD_END = ""
INCLUDE_HEADER = '#include "cpp-fsm/generated/sm_definition.hpp"\n'
TRANSITION_RESULT = """\
    // You should check this after consume
    enum class TransitionResult : unsigned int {
        /// @brief Everything is ok
        Ok,
        /// @brief Returned by Consume when the given input is not relivent to the current state. Usually implies a bug is present
        TransitionImpossable,
        /// @brief This shouldnt be possable if the user uses the Input enum but just in case
        InvalidStateBug,
    };
"""
HEADER_INCLUDES = """\
// Included for static assert in state machine runner function
#include <type_traits>
#include <string>

"""

# Build an enum containing all of the supported states
def build_states_enum(states,sm):
    output = "/// @brief This enum contains all of the valid states of the state machine\n"
    output += "    enum class State : unsigned int {\n"
    for i in states:
        if (sm["states"][i]["doc"] != None):
            output += "        /// @brief {}\n".format(sm["states"][i]["doc"])
        output += "        {},\n".format(i)
    output += "    };"
    return output

# Build an enum containing all of the supported inputs
def build_inputs_enum(inputs):
    output = "/// @brief This contains all valid inputs for the state machine\n"
    output += "    enum class Input : unsigned int {\n"
    for i in inputs:
        output += "        {},\n".format(i)
    output += "    };"
    return output

# Build an state machine class
def build_state_machine_class_src(sm):
    output = """
/// @brief Constructor
{sm_name}SM::{sm_name}SM() noexcept {{
    current_state = {sm_name}SM::State::{initial_state};
    previous_state = {sm_name}SM::State::{initial_state};
}};

/// @brief Get the current state
{sm_name}SM::State {sm_name}SM::GetState() {{
   return current_state;
}};

/// @brief Get the previous state
{sm_name}SM::State {sm_name}SM::GetPreviousState() {{
   return previous_state;
}};


/**
 * @brief Handles state transitions for the {sm_name} State Machine based on the given input.
 *
 * This function takes an input and transitions the state machine to the appropriate next state
 * based on the current state and the input provided. It returns a TransitionResult indicating
 * the outcome of the transition.
 *
 * @param input The input event that triggers a state transition.
 * @return TransitionResult indicating the result of the state transition.
 */
{sm_name}SM::TransitionResult {sm_name}SM::Consume(Input input) {{
  {consume_impl} 
}};

/// @brief Bypass the checks performed by consume and force the state machine to the desired state
/// @param state The desired state
void {sm_name}SM::OverrideState(State state) {{
   current_state = state; 
}};

const char* {sm_name}SM::ResolveStateToString(State state) {{
    {state_to_string_impl}
}};
    
""".format(sm_name=sm["name"],
           initial_state=sm["initial_state"],
           consume_impl=build_state_machine_consume_src(sm),
           run_impl=build_state_machine_run_src(sm),
           state_to_string_impl=build_state_machine_state_resolve(sm)

           )
    return output

def build_state_machine_run_function(all_states):
    output = "    switch (sm.GetState()) {\n"
    for s in all_states:
        #output += "    /// @brief Inhariter must implement\n"
        output += "        case T::State::{}:\n".format(s)
        output += "            sm.{}Run();\n".format(s)
        output += "            break;\n"
    output += "        // This shouldn't be possable but just in case someone tries\n"
    output += "        //   to do a funky cast to this enum...\n"
    output += "        default:\n"
    output += "            sm.FaultRun();\n"
    output += "            break;\n"
    output += "    }"
    return output

# Build an state machine class
def build_state_machine_class_header(sm_name,initial_state,all_states,sm_inputs,sm):

    output = """

#define MAX_NAME_SIZE 40

class {sm_name}SM {{
public:

    {states_enum}

    {inputs_enum}

    {transition_result}

    /// @brief Constructor
    {sm_name}SM() noexcept;

    /// @brief Gets the current state of the state machine 
    /// @return An enum indicating the current state
    {sm_name}SM::State GetState();

    /// @brief Gets the previous state of the state machine 
    /// @return An enum indicating the previous state
    {sm_name}SM::State GetPreviousState();

    /// @brief TODO
    /// @param input The input to consume
    /// @return An enum indicating if the transition was successfull or not
    {sm_name}SM::TransitionResult Consume(Input input);

    /// @brief Bypass transitions of the state machine
    void OverrideState({sm_name}SM::State state);

    /// @brief Convert a state enum into a string
    const char* ResolveStateToString({sm_name}SM::State);


private:
    State current_state;
    State previous_state;

}};


/// @brief This function is used to run one iteration of the state machine. 
///   Utilizing this function provides compile time guarantees 
///   that all valid states are defined in the child class
/// @tparam T Child class of {sm_name}SM
/// @param sm The state machine to run
template <typename T>
void {sm_name}SM_Run(T& sm) {{

    // Make sure T actually inhereted {sm_name}SM
    static_assert(
        std::is_base_of<{sm_name}SM, T>::value, 
        "T must inherit from {sm_name}SM"
    );

    // Switch on all valid states
{state_functions}

}}
""".format(sm_name=sm_name,
           initial_state=initial_state,
           state_functions=build_state_machine_run_function(all_states),
           states_enum= build_states_enum(all_states,sm),
           inputs_enum= build_inputs_enum(sm_inputs),
           transition_result=TRANSITION_RESULT)
    return output

# build the consume function for state transitions
def build_state_machine_consume_src(sm):
    output = "// Switch on the current state"
    output += "\n   switch (current_state) {\n"
    for s in sm["states"]:
        output += "      case {name}SM::State::{state}:\n".format(name=sm["name"],state=s)
        output += "         switch(input) {\n"
        for t in sm["states"][s]["transitions"]:
            output += "            case {name}SM::Input::{input}:\n".format(name=sm["name"],input=t[0])
            output += "               previous_state = GetState();\n".format(name=sm["name"],state=t[1])
            output += "               current_state = {name}SM::State::{state};\n".format(name=sm["name"],state=t[1])
            output += "               break;\n"
        # Add default case
        output += "            default:\n"
        output += "               return TransitionResult::TransitionImpossable;\n"

        output += "         }\n"
        output += "         break;\n"

    output += "      default:\n"
    output += "         return TransitionResult::InvalidStateBug;\n"
    output += "   }\n"
    output += "   return TransitionResult::Ok;\n"

    
    return output


# build the consume function for state transitions
def build_state_machine_run_src(sm):
    output = "// Switch on the current state\n   switch (current_state) {\n"
    for s in sm["states"]:
        output += "      case State::{state}:\n".format(name=sm["name"],state=s)
        output += "         {}Run();\n".format(s)
        output += "         break;\n"

    output += "      default:\n"
    output += "         return TransitionResult::InvalidStateBug;\n"
    output += "   }\n"
    output += "   return TransitionResult::Ok;\n"

    
    return output

# build the consume function for state transitions
def build_state_machine_state_resolve(sm):
    output = "// Switch on input state and return string of state\n   switch (state) {\n"
    for s in sm["states"]:
        output += "      case State::{state}:\n".format(name=sm["name"],state=s)
        output += "         return \"{}\";\n".format(s)
    output += "      default:\n"
    output += "         return \"Unknown/InvalidStateBug\";\n"
    output += "   }\n"
    
    return output




if (len(sys.argv) <= 1):
    print("Error: Not enough args")
    exit(1)

for current_sm_file in sys.argv[1:]:

    # Get the current file and its path
    sm_file_name = os.path.basename(current_sm_file)
    sm_file_path = current_sm_file.replace(sm_file_name,"")

    # Parse the state machine definition
    sm = []
    sm = parse(current_sm_file)

    # Get information from parsed data
    sm_name = sm["name"]
    sm_initial_state = sm["initial_state"]
    sm_inputs = []
    sm_states = []

    if debug:
        print("NAME: ",sm_name)
        print("INITIAL_STATE: ",sm_initial_state)
        print(sm)
    for s in sm["states"]:
        if debug:
            print(s)
            print("doc:",sm["states"][s]["doc"])
        sm_states.append(s)
        for t in sm["states"][s]:
            for i in sm["states"][s]["transitions"][:]:
                sm_inputs.append(i[0])
            #sm_inputs.append(sm["states"][s]["transitions"][:][0])
            if debug:
                print("\t",t)


    # Remove duplicates from inputs. states shouldnt contain duplicates but just in case
    sm_inputs = list(set(sm_inputs))
    sm_states = list(set(sm_states))

    # Sort in alphabetical order so the output order is always the same
    sm_inputs.sort()
    sm_states.sort()

    if debug:
        print("inputs:",sm_states)
        print("inputs:",sm_inputs)

    # Eventually we will pull this from a cmake env
    if not os.path.exists("generated"):
        os.makedirs("generated")
    if not os.path.exists("generated/src"):
        os.makedirs("generated/src")
    if not os.path.exists("generated/include"):
        os.makedirs("generated/include")
    if not os.path.exists("generated/include/cpp-fsm"):
        os.makedirs("generated/include/cpp-fsm")


    with open("generated/include/cpp-fsm/{}.hpp".format(sm_file_name.replace(".sm","")),"w") as f:

        f.write(GENERATED_CODE_BANNER)
        f.write(HEADER_GUARD_START)
        f.write(HEADER_INCLUDES)

        # Write a class that contains the state machine
        f.write(build_state_machine_class_header(sm_name,sm_initial_state,sm_states,sm_inputs,sm))

        f.write(HEADER_GUARD_END)

    with open("generated/src/{}.cpp".format(sm_file_name.replace(".sm","")),"w") as f:
        f.write(GENERATED_CODE_BANNER)

        #f.write(INCLUDE_HEADER)
        f.write('#include "cpp-fsm/{}"\n'.format(sm_file_name.replace(".sm",".hpp")))

        # Write a class inplementation that contains the state machine
        f.write(build_state_machine_class_src(sm))

    reset()

