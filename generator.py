import os
from parser import parse

# TODO ADD like converting state to string and stuff for debugging

GENERATED_CODE_BANNER = """\
//**************************************************************
//*** NOTICE: This file was generated by CPP-FSM DO NOT EDIT ***
//**************************************************************

"""

HEADER_GUARD_START = """\
#ifndef SM_DEFINITION_HEADER_GUARD 
#define SM_DEFINITION_HEADER_GUARD

"""
HEADER_GUARD_END = "#endif"
INCLUDE_HEADER = '#include "cpp-fsm/generated/sm_definition.hpp"\n'
TRANSITION_RESULT = """\
#ifndef SM_TRANSITION_RESULT_GUARD
#define SM_TRANSITION_RESULT_GUARD
// You should check this after consume
enum TransitionResult {
    Ok,
    TransitionImpossable,
    InvalidStateBug,
};
#endif

"""

# Build an enum containing all of the supported states
def build_states_enum(sm_name,states,sm):
    output = "enum {}State {{\n".format(sm_name)
    for i in states:
        if (sm["states"][i]["doc"] != None):
            output += "   /// {}\n".format(sm["states"][i]["doc"])
        output += "   {},\n".format(i)
    output += "};\n\n"
    return output

# Build an enum containing all of the supported inputs
def build_inputs_enum(sm_name,inputs):
    output = "enum {}Input {{\n".format(sm_name)
    for i in inputs:
        output += "   {},\n".format(i)
    output += "};\n\n"
    return output

# Build an state machine class
def build_state_machine_class_src(sm):
    output = """
// Constructor
StateMachine::StateMachine() {{
    current_state = {sm_name}State::{initial_state};
}};

// Get the current state
{sm_name}State StateMachine::state() {{
   return current_state;
}};

// Need to implement
TransitionResult StateMachine::consume({sm_name}Input input) {{
  {consume_impl} 
}};
    
""".format(sm_name=sm["name"],initial_state=sm["initial_state"],consume_impl=build_state_machine_consume_src(sm))
    return output

# Build an state machine class
def build_state_machine_class_header(sm_name,initial_state):
    output = """
class StateMachine {{
private:
    {sm_name}State current_state;
public:
    {sm_name}State state();
    int consume({sm_name}Input);
}};
""".format(sm_name=sm_name,initial_state=initial_state)
    return output

# build the consume function for state transitions
def build_state_machine_consume_src(sm):
    output = "// Switch on the current state\n   switch (current_state) {\n"
    for s in sm["states"]:
        output += "      case {name}State::{state}:\n".format(name=sm["name"],state=s)
        output += "         switch(input) {\n"
        for t in sm["states"][s]:
            output += "            case {name}Input::{input}:\n".format(name=sm["name"],input=t[0])
            output += "               current_state = {name}State::{state};\n".format(name=sm["name"],state=t[1])
            output += "               break;\n"
        # Add default case
        output += "            default:\n"
        output += "               return TransitionResult::Impossable;\n"

        output += ""
        output += "         }\n"
        output += "         break;\n"

    output += "      default:\n"
    output += "         return TransitionResult::InvalidStateBug;\n"
    output += "   }\n"
    output += "   return TransitionResult::Ok;\n"

    
    return output


sm = parse("state_machine_config.sm")

sm_name = sm["name"]
sm_initial_state = sm["initial_state"]
sm_inputs = []
sm_states = []

print("NAME: ",sm_name)
print("INITIAL_STATE: ",sm_initial_state)
for s in sm["states"]:
    print(s)
    print("doc:",sm["states"][s]["doc"])
    sm_states.append(s)
    for t in sm["states"][s]:
        sm_inputs.append(sm["states"][s]["transitions"][0][0])
        print("\t",t)

# Remove duplicates from inputs. states shouldnt contain duplicates but just in case
sm_inputs = list(set(sm_inputs))
sm_states = list(set(sm_states))

print("inputs:",sm_states)
print("inputs:",sm_inputs)

# Eventually we will pull this from a cmake env
if not os.path.exists("generated"):
    os.makedirs("generated")

with open("generated/sm_definition.hpp","w") as f:

    f.write(GENERATED_CODE_BANNER)
    f.write(HEADER_GUARD_START)
    f.write(TRANSITION_RESULT)

    # Generate the enum representing all states
    f.write(build_states_enum(sm_name,sm_states,sm))

    # Generate the enum representing all states
    f.write(build_inputs_enum(sm_name,sm_inputs))

    # Write a class that contains the state machine
    f.write(build_state_machine_class_header(sm_name,sm_initial_state))

    f.write(HEADER_GUARD_END)

with open("generated/sm_definition.cpp","w") as f:
    f.write(GENERATED_CODE_BANNER)

    f.write(INCLUDE_HEADER)

    # Write a class inplementation that contains the state machine
    f.write(build_state_machine_class_src(sm))

